{"version":3,"file":"pixi-tilemap.mjs","sources":["../src/settings.ts","../src/TilemapGeometry.ts","../src/TilemapPipe.ts","../src/TileTextureArray.ts","../src/gl_tilemap.ts","../src/gpu_tilemap.ts","../src/Tilemap.ts","../src/CompositeTilemap.ts","../src/index.ts"],"sourcesContent":["import { SCALE_MODE } from 'pixi.js';\r\n\r\n/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */\r\nexport const settings = {\r\n    /** The default number of textures per tilemap in a tilemap composite. */\r\n    TEXTURES_PER_TILEMAP: 16,\r\n\r\n    /** The scaling mode of the combined texture tiling. */\r\n    TEXTILE_SCALE_MODE: 'linear' as SCALE_MODE,\r\n\r\n    /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\r\n    use32bitIndex: false,\r\n};\r\n\r\n// @deprecated\r\nexport const Constant = settings;\r\n","import { Buffer, BufferUsage, Geometry } from 'pixi.js';\r\n\r\n// For some reason, ESLint goes mad with indentation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\nexport class TilemapGeometry extends Geometry\r\n{\r\n    static vertSize = 13;\r\n    static vertPerQuad = 4;\r\n    static stride = this.vertSize * 4;\r\n    lastTimeAccess = 0;\r\n\r\n    vertSize = TilemapGeometry.vertSize;\r\n    vertPerQuad = TilemapGeometry.vertPerQuad;\r\n    stride = TilemapGeometry.stride;\r\n\r\n    constructor(indexBuffer: Buffer)\r\n    {\r\n        const buf = new Buffer({\r\n            data: new Float32Array(2),\r\n            label: 'tilemap-buffer',\r\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\r\n            shrinkToFit: false,\r\n        });\r\n\r\n        const stride = TilemapGeometry.stride;\r\n\r\n        // TODO: why location is like that in webgl? ascending?\r\n\r\n\t    super({\r\n            indexBuffer,\r\n            attributes: {\r\n                aVertexPosition: {\r\n                    buffer: buf,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 0,\r\n                    // location: 6,\r\n                },\r\n                aTextureCoord: {\r\n                    buffer: buf,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 2 * 4,\r\n                    // location: 4,\r\n                },\r\n                aFrame: {\r\n                    buffer: buf,\r\n                    format: 'float32x4',\r\n                    stride,\r\n                    offset: 4 * 4,\r\n                    // location: 3,\r\n                },\r\n                aAnim: {\r\n                    buffer: buf,\r\n                    format: 'float32x2',\r\n                    stride,\r\n                    offset: 8 * 4,\r\n                    // location: 1,\r\n                },\r\n                aTextureId: {\r\n                    buffer: buf,\r\n                    format: 'sint32',\r\n                    stride,\r\n                    offset: 10 * 4,\r\n                    // location: 5\r\n                },\r\n                aAnimDivisor: {\r\n                    buffer: buf,\r\n                    format: 'float32',\r\n                    stride,\r\n                    offset: 11 * 4,\r\n                    // location: 2\r\n                },\r\n                aColMul: {\r\n                    buffer: buf,\r\n                    format: 'float32x4',\r\n                    stride,\r\n                    offset: 12 * 4,\r\n                    // location: 0\r\n                }\r\n            },\r\n        });\r\n\r\n        this.buf = buf;\r\n    }\r\n\r\n    buf: Buffer;\r\n}\r\n","import {\r\n    Buffer,\r\n    BufferUsage, ExtensionType, GlobalUniformGroup,\r\n    IndexBufferArray, Instruction, InstructionPipe, InstructionSet, Matrix, Renderer,\r\n    RenderPipe, UniformGroup\r\n} from 'pixi.js';\r\nimport { CompositeTilemap } from './CompositeTilemap';\r\nimport { settings } from './settings';\r\nimport { TilemapGeometry } from './TilemapGeometry';\r\n\r\nimport type { Tilemap } from './Tilemap';\r\n\r\n// For some reason, ESLint goes mad with indentation in this file ^&^\r\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\r\n\r\nexport abstract class TilemapAdaptor\r\n{\r\n    abstract init(): void;\r\n    abstract execute(meshPipe: TilemapPipe, mesh: Tilemap): void;\r\n    abstract destroy(): void;\r\n\r\n    public pipe_uniforms = new UniformGroup({\r\n        u_proj_trans: { value: new Matrix(), type: 'mat3x3<f32>' },\r\n        u_anim_frame: { value: new Float32Array(2), type: 'vec2<f32>' },\r\n    });\r\n}\r\n\r\nexport interface TilemapInstruction extends Instruction\r\n{\r\n    renderPipeId: 'tilemap';\r\n    tilemap: Tilemap;\r\n}\r\n\r\n/**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */\r\nexport class TilemapPipe implements RenderPipe<Tilemap>, InstructionPipe<TilemapInstruction>\r\n{\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.WebGLPipes,\r\n            ExtensionType.WebGPUPipes,\r\n        ],\r\n        name: 'tilemap',\r\n    } as const;\r\n    /** The managing renderer */\r\n    public readonly renderer: Renderer;\r\n\r\n    /** The tile animation frame */\r\n    public tileAnim = [0, 0];\r\n\r\n    private ibLen = 0;// index buffer length\r\n\r\n    /** The index buffer for the tilemaps to share. */\r\n    private indexBuffer: Buffer | null = null;\r\n\r\n    /** The shader used to render tilemaps. */\r\n    private shader: TilemapGeometry | null = null;\r\n\r\n    private adaptor: TilemapAdaptor;\r\n\r\n    constructor(renderer: Renderer, adaptor: TilemapAdaptor)\r\n    {\r\n        this.renderer = renderer;\r\n        this.adaptor = adaptor;\r\n\r\n        this.adaptor.init();\r\n\r\n\t    this.indexBuffer = new Buffer({\r\n            data: new Uint16Array([0, 1, 2, 0, 2, 3]),\r\n            label: 'index-tilemap-buffer',\r\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\r\n        });\r\n\t    this.checkIndexBuffer(2000);\r\n    }\r\n\r\n    start(): void\r\n    {\r\n\t    // sorry, nothing\r\n    }\r\n\r\n    /**\r\n\t * @internal\r\n\t * @ignore\r\n\t */\r\n    createVb(): TilemapGeometry\r\n    {\r\n        if(!this.indexBuffer) throw new Error('Index buffer is not initialized');\r\n\r\n\t    const geom = new TilemapGeometry(this.indexBuffer);\r\n\r\n        geom.lastTimeAccess = Date.now();\r\n\r\n\t    return geom;\r\n    }\r\n\r\n    /** @return The {@link TilemapGeometry} shader that this rendering pipeline is using. */\r\n    getShader(): TilemapGeometry | null { return this.shader; }\r\n\r\n    destroy(): void\r\n    {\r\n\t    // this.rectShader.destroy();\r\n\t    this.shader = null;\r\n    }\r\n\r\n    // eslint-disable-next-line no-unused-vars\r\n    public checkIndexBuffer(size: number): void\r\n    {\r\n        if(!this.indexBuffer) throw new Error('Index buffer is not initialized');\r\n\r\n\t    const totalIndices = size * 6;\r\n\r\n\t    if (totalIndices <= this.ibLen)\r\n\t    {\r\n\t        return;\r\n\t    }\r\n\r\n\t    let len = totalIndices;\r\n\r\n\t    while (len < totalIndices)\r\n\t    {\r\n\t        len <<= 1;\r\n\t    }\r\n\r\n\t    this.ibLen = totalIndices;\r\n\t    this.indexBuffer.data = createIndicesForQuads(size,\r\n\t        settings.use32bitIndex ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices));\r\n    }\r\n\r\n    destroyRenderable(_renderable: Tilemap): void\r\n    {\r\n        _renderable.vb?.destroy(true);\r\n        _renderable.vb = null;\r\n    }\r\n\r\n    addRenderable(tilemap: Tilemap, instructionSet: InstructionSet | undefined): void\r\n    {\r\n        const batcher = this.renderer.renderPipes.batch;\r\n\r\n        tilemap.updateBuffer(this);\r\n        tilemap.checkValid();\r\n        tilemap.getTileset().update();\r\n\r\n        if (tilemap.is_valid)\r\n        {\r\n            if(!instructionSet) throw new Error('Instruction set is not initialized');\r\n\r\n            batcher.break(instructionSet);\r\n            instructionSet.add(tilemap._instruction);\r\n        }\r\n    }\r\n\r\n    updateRenderable(tilemap: Tilemap, _instructionSet?: InstructionSet | undefined): void\r\n    {\r\n        tilemap.updateBuffer(this);\r\n        tilemap.getTileset().update();\r\n    }\r\n\r\n    validateRenderable(renderable: Tilemap): boolean\r\n    {\r\n        return renderable.checkValid();\r\n    }\r\n\r\n    public execute({ tilemap }: TilemapInstruction)\r\n    {\r\n        if (!tilemap.isRenderable) return;\r\n\r\n        tilemap.state.blendMode = tilemap.groupBlendMode;\r\n\r\n        const { pipe_uniforms } = this.adaptor;\r\n\r\n        const u_proj_trans = pipe_uniforms.uniforms.u_proj_trans;\r\n        const u_global = ((this.renderer.globalUniforms as any)._activeUniforms.at(-1) as GlobalUniformGroup).uniforms;\r\n        let anim_frame = this.tileAnim;\r\n        const { u_anim_frame } = pipe_uniforms.uniforms;\r\n\r\n        u_global.uProjectionMatrix.copyTo(u_proj_trans).append(u_global.uWorldTransformMatrix)\r\n            .append(tilemap.worldTransform);\r\n        if (tilemap.compositeParent)\r\n        {\r\n            anim_frame = (tilemap.parent as CompositeTilemap).tileAnim || anim_frame;\r\n        }\r\n        u_anim_frame[0] = anim_frame[0];\r\n        u_anim_frame[1] = anim_frame[1];\r\n\r\n        pipe_uniforms.update();\r\n\r\n        this.adaptor.execute(this, tilemap);\r\n    }\r\n}\r\n\r\nfunction createIndicesForQuads(\r\n    size: number,\r\n    outBuffer: IndexBufferArray\r\n): IndexBufferArray\r\n{\r\n    // the total number of indices in our array, there are 6 points per quad.\r\n    const totalIndices = size * 6;\r\n\r\n    if (outBuffer.length !== totalIndices)\r\n    {\r\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\r\n    }\r\n\r\n    // fill the indices with the quads to draw\r\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\r\n    {\r\n        outBuffer[i + 0] = j + 0;\r\n        outBuffer[i + 1] = j + 1;\r\n        outBuffer[i + 2] = j + 2;\r\n        outBuffer[i + 3] = j + 0;\r\n        outBuffer[i + 4] = j + 2;\r\n        outBuffer[i + 5] = j + 3;\r\n    }\r\n\r\n    return outBuffer;\r\n}\r\n","import { BindGroup, Buffer, BufferUsage, Texture, TextureSource, UniformGroup } from 'pixi.js';\r\n\r\nexport class TileTextureArray\r\n{\r\n    max_textures: number;\r\n    constructor(max_textures: number)\r\n    {\r\n        this.max_textures = max_textures;\r\n        this.tex_sizes = new Float32Array((this.max_textures * 4) + 4);\r\n        this.tex_buf = new Buffer({\r\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\r\n        });\r\n    }\r\n\r\n    arr: TextureSource[] = [];\r\n    count = 0;\r\n    dirty = false;\r\n    dirty_gpu = false;\r\n    bind_group: BindGroup | null = null;\r\n    bind_group_resources: any = {};\r\n    tex_sizes: Float32Array | null = null;\r\n    null_color: Float32Array = new Float32Array([0, 0, 0, 0.5]);\r\n    tex_buf: Buffer | null = null;\r\n\r\n    get length()\r\n    {\r\n        return this.count;\r\n    }\r\n\r\n    push(tex: TextureSource)\r\n    {\r\n        this.arr[this.count++] = tex;\r\n        this.dirty = true;\r\n    }\r\n\r\n    at(ind: number)\r\n    {\r\n        return this.arr[ind];\r\n    }\r\n\r\n    update()\r\n    {\r\n        if (!this.dirty)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.dirty = false;\r\n        this.dirty_gpu = true;\r\n\r\n        const { tex_sizes, arr, count, max_textures, null_color } = this;\r\n\r\n        if(!tex_sizes)\r\n            throw new Error('Texture sizes buffer is not initialized');\r\n\r\n        for (let i = 0; i < count; i++)\r\n        {\r\n            const tex = arr[i];\r\n\r\n            if (tex)\r\n            {\r\n                tex_sizes[(i * 4)] = tex.pixelWidth;\r\n                tex_sizes[(i * 4) + 1] = tex.pixelHeight;\r\n                tex_sizes[(i * 4) + 2] = 1.0 / tex.pixelWidth;\r\n                tex_sizes[(i * 4) + 3] = 1.0 / tex.pixelHeight;\r\n            }\r\n        }\r\n\r\n        tex_sizes[max_textures * 4] = null_color[0];\r\n        tex_sizes[(max_textures * 4) + 1] = null_color[1];\r\n        tex_sizes[(max_textures * 4) + 2] = null_color[2];\r\n        tex_sizes[(max_textures * 4) + 3] = null_color[3];\r\n    }\r\n\r\n    markDirty()\r\n    {\r\n        this.dirty = true;\r\n    }\r\n\r\n    getBindGroup()\r\n    {\r\n        this.update();\r\n        if (!this.dirty_gpu)\r\n        {\r\n            return this.bind_group;\r\n        }\r\n\r\n        const { bind_group_resources, max_textures, arr, count } = this;\r\n\r\n        let bindIndex = 0;\r\n\r\n        bind_group_resources[bindIndex++] = new UniformGroup({\r\n            u_texture_size: {\r\n                value: this.tex_sizes,\r\n                type: 'vec4<f32>',\r\n                size: max_textures\r\n            },\r\n            u_null_color: {\r\n                value: this.null_color,\r\n                type: 'vec4<f32>'\r\n            },\r\n        });\r\n\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            const texture = (i < count ? arr[i] : null) || Texture.EMPTY.source;\r\n\r\n            bind_group_resources[bindIndex++] = texture.source;\r\n            bind_group_resources[bindIndex++] = texture.style;\r\n        }\r\n\r\n        if (!this.bind_group)\r\n        {\r\n            this.bind_group = new BindGroup(bind_group_resources);\r\n        }\r\n\r\n        return this.bind_group;\r\n    }\r\n\r\n    static generate_gpu_textures(max_textures: number): string\r\n    {\r\n        const src: string[] = [];\r\n\r\n        src.push(`struct TextureArrayFields {`);\r\n        src.push(`    u_texture_size: array<vec4f, ${max_textures}>,`);\r\n        src.push(`    u_null_color: vec4f`);\r\n        src.push(`}`);\r\n        src.push(`@group(1) @binding(0) var<uniform> taf: TextureArrayFields;`);\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            src.push(`@group(1) @binding(${(i * 2) + 1}) var u_texture_${i}: texture_2d<f32>;`);\r\n            src.push(`@group(1) @binding(${(i * 2) + 2}) var u_sampler_${i}: sampler;`);\r\n        }\r\n\r\n        src.push('fn sampleMultiTexture(texture_id: i32, uv: vec2f, dx: vec2f, dy: vec2f) -> vec4f {');\r\n        src.push(`switch texture_id {`);\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            src.push(`  case ${i}: { return textureSampleGrad(u_texture_${i}, u_sampler_${i}, uv, dx, dy); }`);\r\n        }\r\n        src.push(`  default: { return taf.u_null_color; }`);\r\n        src.push('} }');\r\n\r\n        return src.join('\\n');\r\n    }\r\n\r\n    static generate_gl_textures(max_textures: number): string\r\n    {\r\n        const src: string[] = [];\r\n\r\n        src.push(`uniform vec4 u_texture_size[${max_textures + 1}];`);\r\n        src.push(`uniform sampler2D u_textures[${max_textures}];`);\r\n        src.push(`uniform vec4 u_null_color;`);\r\n\r\n        src.push('vec4 sampleMultiTexture(float texture_id, vec2 uv) {');\r\n        src.push(`if(texture_id < -0.5) return u_texture_size[${max_textures}];`);\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            src.push(`if(texture_id < ${i}.5) return texture(u_textures[${i}], uv * u_texture_size[${i}].zw);`);\r\n        }\r\n        src.push(`return u_texture_size[${max_textures}];`);\r\n        src.push('}');\r\n\r\n        return src.join('\\n');\r\n    }\r\n\r\n    static gl_gen_resources(max_textures: number): any\r\n    {\r\n        const sampleValues: Array<number> = [];\r\n\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            sampleValues[i] = i;\r\n        }\r\n\r\n        const samplerSize: Array<number> = [];\r\n\r\n        for (let i = 0; i < max_textures; i++)\r\n        {\r\n            // These are overwritten by TilemapRenderer when textures actually bound.\r\n            samplerSize.push(2048);\r\n            samplerSize.push(2048);\r\n            samplerSize.push(1.0 / 2048);\r\n            samplerSize.push(1.0 / 2048);\r\n        }\r\n\r\n        return {\r\n            u_textures: {\r\n                value: sampleValues,\r\n                type: 'i32',\r\n                size: max_textures\r\n            },\r\n            u_texture_size: {\r\n                value: samplerSize,\r\n                type: 'vec4<f32>',\r\n                size: max_textures\r\n            }\r\n        };\r\n    }\r\n}\r\n","import { ExtensionType, GlProgram, Shader, UniformGroup, WebGLRenderer } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { Tilemap } from './Tilemap';\r\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\r\nimport { TileTextureArray } from './TileTextureArray';\r\n\r\nconst gl_tilemap_vertex = `\r\nin vec2 aVertexPosition;\r\nin vec2 aTextureCoord;\r\nin vec4 aFrame;\r\nin vec2 aAnim;\r\nin float aAnimDivisor;\r\nin float aTextureId;\r\nin vec4 aColMul;\r\n\r\nuniform mat3 u_proj_trans;\r\nuniform vec2 u_anim_frame;\r\n\r\nout vec2 vTextureCoord;\r\nout float vTextureId;\r\nout vec4 vFrame;\r\nout vec4 vColMul;\r\n\r\nvoid main(void)\r\n{\r\n  gl_Position = vec4((u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n  vec2 animCount = floor((aAnim + 0.5) / 2048.0);\r\n  vec2 animFrameOffset = aAnim - animCount * 2048.0;\r\n  vec2 currentFrame = floor(u_anim_frame / aAnimDivisor);\r\n  vec2 loop_num = floor((currentFrame + 0.5) / animCount);\r\n  vec2 animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\r\n\r\n  vTextureCoord = aTextureCoord + animOffset;\r\n  vFrame = aFrame + vec4(animOffset, animOffset);\r\n  vTextureId = aTextureId;\r\n  vColMul = aColMul;\r\n}\r\n`;\r\n\r\nconst gl_tilemap_fragment = `\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\nin vec2 vTextureCoord;\r\nin vec4 vFrame;\r\nin float vTextureId;\r\nin vec4 vColMul;\r\n\r\n//include_textures\r\n\r\nvoid main(void)\r\n{\r\n  float textureId = floor(vTextureId + 0.5);\r\n  vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\r\n  vec4 color = sampleMultiTexture(textureId, textureCoord);\r\n  finalColor = color * vColMul;\r\n}\r\n`;\r\n\r\nexport class GlTilemapAdaptor extends TilemapAdaptor\r\n{\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.WebGLPipesAdaptor,\r\n        ],\r\n        name: 'tilemap',\r\n    } as const;\r\n\r\n    _shader: Shader | null = null;\r\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\r\n\r\n    destroy(): void\r\n    {\r\n        this._shader?.destroy(true);\r\n        this._shader = null;\r\n    }\r\n\r\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\r\n    {\r\n        const renderer = pipe.renderer as WebGLRenderer;\r\n        const shader = this._shader;\r\n        const tileset = tilemap.getTileset();\r\n\r\n        const tu = shader?.resources.texture_uniforms;\r\n\r\n        if (tu.uniforms.u_texture_size !== tileset.tex_sizes)\r\n        {\r\n            tu.uniforms.u_texture_size = tileset.tex_sizes;\r\n            tu.update();\r\n        }\r\n\r\n        for (let i = 0; i < tileset.length; i++)\r\n        {\r\n            renderer.texture.bind(tileset.arr[i], i);\r\n        }\r\n        if(shader) {\r\n            if(!tilemap.vb)\r\n                throw new Error('Tilemap vertex buffer is not initialized');\r\n            renderer.encoder.draw({\r\n                geometry: tilemap.vb,\r\n                shader,\r\n                state: tilemap.state,\r\n                size: tilemap.rects_count * 6\r\n            });\r\n        } else {\r\n            throw new Error('Shader is not initialized');\r\n        }\r\n    }\r\n\r\n    init(): void\r\n    {\r\n        this._shader = new Shader({\r\n            glProgram: GlProgram.from({\r\n                vertex: gl_tilemap_vertex,\r\n                fragment: gl_tilemap_fragment.replace('//include_textures',\r\n                    TileTextureArray.generate_gl_textures(this.max_textures))\r\n            }),\r\n            resources: {\r\n                texture_uniforms: new UniformGroup(TileTextureArray.gl_gen_resources(this.max_textures), { isStatic: true }),\r\n                pipe_uniforms: this.pipe_uniforms.uniformStructures,\r\n            },\r\n        });\r\n    }\r\n}\r\n","import { BindGroup, ExtensionType, GpuProgram, Shader } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { Tilemap } from './Tilemap';\r\nimport { TilemapAdaptor, TilemapPipe } from './TilemapPipe';\r\nimport { TileTextureArray } from './TileTextureArray';\r\n\r\nconst gpu_tilemap_vertex = `\r\nstruct GlobalUniforms {\r\n  uProjectionMatrix:mat3x3f,\r\n  uWorldTransformMatrix:mat3x3f,\r\n  uWorldColorAlpha: vec4f,\r\n  uResolution: vec2f,\r\n}\r\n\r\nstruct TilemapUniforms {\r\n  u_proj_trans:mat3x3f,\r\n  u_anim_frame:vec2f\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\r\n@group(2) @binding(0) var<uniform> loc: TilemapUniforms;\r\n\r\nstruct VSOutput {\r\n  @builtin(position) vPosition: vec4f,\r\n  @location(0) @interpolate(flat) vTextureId : i32,\r\n  @location(1) vTextureCoord : vec2f,\r\n  @location(2) @interpolate(flat) vFrame : vec4f,\r\n  @location(3) vColMul : vec4f\r\n};\r\n\r\n@vertex\r\nfn mainVert(\r\n   @location(6) aVertexPosition: vec2f,\r\n   @location(4) aTextureCoord: vec2f,\r\n   @location(3) aFrame: vec4f,\r\n   @location(1) aAnim: vec2f,\r\n   @location(2) aAnimDivisor: f32,\r\n   @location(5) aTextureId: i32,\r\n   @location(0) aColMul: vec4f,\r\n ) -> VSOutput {\r\n\r\n  var vPosition = vec4((loc.u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n  var animCount = floor((aAnim + 0.5) / 2048.0);\r\n  var animFrameOffset = aAnim - animCount * 2048.0;\r\n  var currentFrame = floor(loc.u_anim_frame / aAnimDivisor);\r\n  var loop_num = floor((currentFrame + 0.5) / animCount);\r\n  var animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\r\n  var vTextureCoord = aTextureCoord + animOffset;\r\n  var vFrame = aFrame + vec4(animOffset, animOffset);\r\n\r\n  return VSOutput(vPosition, aTextureId, vTextureCoord, vFrame, aColMul);\r\n};\r\n`;\r\n\r\nconst gpu_tilemap_fragment = `\r\n//include_textures\r\n\r\n@fragment\r\nfn mainFrag(\r\n  @location(0) @interpolate(flat) vTextureId : i32,\r\n  @location(1) vTextureCoord : vec2f,\r\n  @location(2) @interpolate(flat) vFrame : vec4f,\r\n  @location(3) vColMul : vec4f,\r\n  ) -> @location(0) vec4f {\r\n  var textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\r\n  var uv = textureCoord * taf.u_texture_size[vTextureId].zw;\r\n  var dx = dpdx(uv);\r\n  var dy = dpdy(uv);\r\n  var color = sampleMultiTexture(vTextureId, uv, dx, dy);\r\n  return color * vColMul;\r\n};\r\n`;\r\n\r\nexport class GpuTilemapAdaptor extends TilemapAdaptor\r\n{\r\n    public static extension = {\r\n        type: [\r\n            ExtensionType.WebGPUPipesAdaptor,\r\n        ],\r\n        name: 'tilemap',\r\n    } as const;\r\n\r\n    _shader: Shader | null = null;\r\n    max_textures: number = settings.TEXTURES_PER_TILEMAP;\r\n    bind_group: BindGroup | null = null;\r\n\r\n    destroy(): void\r\n    {\r\n        this._shader?.destroy(true);\r\n        this._shader = null;\r\n    }\r\n\r\n    execute(pipe: TilemapPipe, tilemap: Tilemap): void\r\n    {\r\n        const renderer = pipe.renderer;\r\n        const shader = this._shader;\r\n        // GPU..\r\n        if(shader) {\r\n\r\n            const tilesetBindGroup = tilemap.getTileset().getBindGroup();\r\n            const selfBindGroup = this.bind_group;\r\n\r\n            if(!tilesetBindGroup || !selfBindGroup)\r\n                throw new Error('Tileset or self bind group is not initialized');\r\n\r\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\r\n            shader.groups[1] = tilesetBindGroup;\r\n            shader.groups[2] = selfBindGroup;\r\n\r\n            if(!tilemap.vb)\r\n                throw new Error('Tilemap vertex buffer is not initialized');\r\n\r\n            renderer.encoder.draw({\r\n                geometry: tilemap.vb,\r\n                shader,\r\n                state: tilemap.state,\r\n                size: tilemap.rects_count * 6\r\n            });\r\n        } else {\r\n            throw new Error('Shader or bind group is not initialized');\r\n        }\r\n    }\r\n\r\n    init(): void\r\n    {\r\n        this._shader = new Shader({\r\n            gpuProgram: GpuProgram.from({\r\n                vertex: { source: gpu_tilemap_vertex, entryPoint: 'mainVert' },\r\n                fragment: {\r\n                    source: gpu_tilemap_fragment\r\n                        .replace('//include_textures', TileTextureArray.generate_gpu_textures(this.max_textures))\r\n                },\r\n            })\r\n        });\r\n\r\n        this.bind_group = new BindGroup({\r\n            ut: this.pipe_uniforms\r\n        });\r\n    }\r\n}\r\n","/* eslint-disable no-unused-vars */\nimport { Bounds, Container, groupD8, State, Texture, TextureSource } from 'pixi.js';\nimport { settings } from './settings';\nimport { TilemapInstruction, TilemapPipe } from './TilemapPipe';\nimport { TileTextureArray } from './TileTextureArray';\n\nimport type { DestroyOptions } from 'pixi.js';\nimport type { TilemapGeometry } from './TilemapGeometry';\n\nenum POINT_STRUCT\n    {\n    U,\n    V,\n    X,\n    Y,\n    TILE_WIDTH,\n    TILE_HEIGHT,\n    ROTATE,\n    ANIM_X,\n    ANIM_Y,\n    TEXTURE_INDEX,\n    ANIM_COUNT_X,\n    ANIM_COUNT_Y,\n    ANIM_DIVISOR,\n    COL_R,\n    COL_G,\n    COL_B,\n    COL_A,\n}\n\nexport const POINT_STRUCT_SIZE = (Object.keys(POINT_STRUCT).length / 2);\n\n/**\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\n *\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\n *\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\n * instances.\n *\n * @example\n * import { Tilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Add the spritesheet into your loader!\n * Loader.shared.add('atlas', 'assets/atlas.json');\n *\n * // Make the tilemap once the tileset assets are available.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      // The base-texture is shared between all the tile textures.\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\n *          .tile('grass.png', 0, 0)\n *          .tile('grass.png', 100, 100)\n *          .tile('brick_wall.png', 0, 100);\n * });\n */\nexport class Tilemap extends Container\n{\n    // TODO: make default color work\n    /**\n     * Currently doesnt work.\n     */\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    state = State.for2d();\n\n    is_valid = false;\n\n    public readonly renderPipeId = 'tilemap';\n    public readonly canBundle = true;\n\n    _instruction = {\n        renderPipeId: 'tilemap',\n        tilemap: this as Tilemap\n    } as TilemapInstruction;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    checkValid()\n    {\n        const v = this.tileset.count > 0 && this.pointsBuf.length > 0;\n        const res = this.is_valid !== v;\n\n        this.is_valid = v;\n\n        return res !== v;\n    }\n\n    /**\n     * The tile animation frame.\n     *\n     * @see CompositeTilemap.tileAnim\n     */\n    public tileAnim: [number, number] | null = null;\n\n    /**\n     * This is the last uploaded size of the tilemap geometry.\n     * @ignore\n     */\n    rects_count = 0;\n\n    /** @ignore */\n    compositeParent = false;\n\n    /**\n     * The list of base-textures being used in the tilemap.\n     *\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\n     * should be added after tiles have been added into the map.\n     */\n    protected tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n\n    /**\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\n     */\n    protected readonly tilemapBounds = new Bounds();\n\n    /** Flags whether any animated tile was added. */\n    protected hasAnimatedTile = false;\n\n    /** The interleaved geometry of the tilemap. */\n    private pointsBuf: Array<number> = [];\n\n    /**\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\n     *      base-textures in this array must not be duplicated.\n     */\n    constructor(tileset: TextureSource | Array<TextureSource>)\n    {\n        super();\n        this.setTileset(tileset);\n    }\n\n    /**\n     * @returns The tileset of this tilemap.\n     */\n    getTileset(): TileTextureArray\n    {\n        return this.tileset;\n    }\n\n    /**\n     * Define the tileset used by the tilemap.\n     *\n     * @param textureOrArray - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\n     *  be wrapped into an array. This should not contain any duplicates.\n     */\n    setTileset(textureOrArray: TileTextureArray | TextureSource | Array<TextureSource> = []): this\n    {\n        let ts = this.tileset;\n\n        if (textureOrArray instanceof TileTextureArray)\n        {\n            this.tileset = textureOrArray;\n            this.didViewUpdate = true;\n        }\n        else if (textureOrArray instanceof TextureSource)\n        {\n            if (ts.count === 1 && ts.arr[0] === textureOrArray)\n            {\n                return this;\n            }\n\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n            ts.push(textureOrArray);\n            this.didViewUpdate = true;\n        }\n        else\n        {\n            if (textureOrArray.length === ts.count)\n            {\n                let flag = true;\n\n                for (let i = 0; i < textureOrArray.length; i++)\n                {\n                    if (textureOrArray[i]?.source !== ts.arr[i])\n                    {\n                        flag = false;\n                        break;\n                    }\n                }\n\n                if (flag)\n                {\n                    return this;\n                }\n            }\n\n            ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n\n            for (let i = 0; i < textureOrArray.length; i++)\n            {\n                ts.push(textureOrArray[i]?.source);\n            }\n            this.didViewUpdate = true;\n        }\n\n        return this;\n    }\n\n    /**  Clears all the tiles added into this tilemap. */\n    clear(): this\n    {\n        this.pointsBuf.length = 0;\n        this.rects_count = 0;\n        this.tilemapBounds.clear();\n        this.hasAnimatedTile = false;\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given texture at (x, y).\n     *\n     * @param tileTexture - The tiling texture to render.\n     * @param x - The local x-coordinate of the tile's position.\n     * @param y - The local y-coordinate of the tile's position.\n     * @param options - Additional tile options.\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n     *      animation frame textures in the base-texture.\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n     *      animation frames textures in the base-texture.\n     * @param [options.rotate=0]\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n     *      per row.\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n     *      per column.\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\n     * @param [options.col_r=1] - Tile red multiplier\n     * @param [options.col_g=1] - Tile green multiplier\n     * @param [options.col_b=1] - Tile blue multiplier\n     * @param [options.col_a=1] - Tile alpha multiplier\n     * @return This tilemap, good for chaining.\n     */\n    tile(\n        tileTexture: number | string | Texture | TextureSource,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number,\n            animDivisor?: number,\n            colR?: number,\n            colG?: number,\n            colB?: number,\n            colA?: number,\n        } = {}\n    ): this\n    {\n        this.didViewUpdate = true;\n        let baseTexture: TextureSource;\n        let textureIndex = -1;\n        let was_num = false;\n\n        if (typeof tileTexture === 'number')\n        {\n            textureIndex = tileTexture;\n            was_num = true;\n            baseTexture = this.tileset.arr[textureIndex];\n        }\n        else\n        {\n            let texture: Texture | TextureSource;\n\n            if (typeof tileTexture === 'string')\n            {\n                texture = Texture.from(tileTexture);\n            }\n            else\n            {\n                texture = tileTexture;\n            }\n\n            const textureList = this.tileset;\n\n            for (let i = 0; i < textureList.count; i++)\n            {\n                if (textureList.arr[i] === texture.source)\n                {\n                    textureIndex = i;\n                    break;\n                }\n            }\n\n            if ('frame' in texture)\n            {\n                options.u = options.u ?? texture.frame.x;\n                options.v = options.v ?? texture.frame.y;\n                options.tileWidth = options.tileWidth ?? texture.orig.width;\n                options.tileHeight = options.tileHeight ?? texture.orig.height;\n            }\n\n            baseTexture = texture.source;\n        }\n\n        if (!was_num && !baseTexture)\n        {\n            console.error('The tile texture was not found in the tilemap tileset.');\n\n            return this;\n        }\n\n        const {\n            u = 0,\n            v = 0,\n            tileWidth = baseTexture.width,\n            tileHeight = baseTexture.height,\n            animX = 0,\n            animY = 0,\n            rotate = 0,\n            animCountX = 1024,\n            animCountY = 1024,\n            animDivisor = 1,\n            colR = 1,\n            colG = 1,\n            colB = 1,\n            colA = 1,\n        } = options;\n\n        const pb = this.pointsBuf;\n\n        this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\n\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(rotate);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureIndex);\n        pb.push(animCountX);\n        pb.push(animCountY);\n        pb.push(animDivisor);\n        pb.push(colR);\n        pb.push(colG);\n        pb.push(colB);\n        pb.push(colA);\n\n        this.tilemapBounds.addFrame(x, y, x + tileWidth, y + tileHeight);\n\n        return this;\n    }\n\n    /** Changes the rotation of the last tile. */\n    tileRotate(rotate: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.TEXTURE_INDEX)] = rotate;\n    }\n\n    /** Changes the `animX`, `animCountX` of the last tile. */\n    tileAnimX(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_X)] = offset;\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_X)] = count;\n        // pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\n    }\n\n    /** Changes the `animY`, `animCountY` of the last tile. */\n    tileAnimY(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_Y)] = offset;\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_COUNT_Y)] = count;\n    }\n\n    /** Changes the `animDivisor` value of the last tile. */\n    tileAnimDivisor(divisor: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = divisor;\n    }\n\n    tileR(r: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.COL_R)] = r;\n    }\n\n    tileG(g: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.COL_G)] = g;\n    }\n\n    tileB(b: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.COL_B)] = b;\n    }\n\n    tileA(a: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.COL_A)] = a;\n    }\n\n    private vbId = 0;\n    vb: TilemapGeometry | null = null;\n    private vbBuffer: ArrayBuffer | null = null;\n    private vbArray: Float32Array | null = null;\n    private vbInts: Uint32Array | null = null;\n\n    private destroyVb(): void\n    {\n        if (this.vb)\n        {\n            this.vb.destroy();\n            this.vb = null;\n        }\n    }\n\n    updateBuffer(plugin: TilemapPipe)\n    {\n        const points = this.pointsBuf;\n        const rects_count = points.length / POINT_STRUCT_SIZE;\n        let vb = this.vb;\n\n        if (this.tileset.count === 0 || rects_count === 0 || (this.rects_count === rects_count && vb))\n        {\n            return;\n        }\n        this.rects_count = rects_count;\n\n        // lost context! recover!\n\n        if (!vb)\n        {\n            vb = plugin.createVb();\n            this.vb = vb;\n            this.vbId = (vb as any).id;\n            this.vbBuffer = null;\n        }\n\n        // if layer was changed, re-upload vertices\n        const vertices = rects_count * vb.vertPerQuad;\n\n        plugin.checkIndexBuffer(rects_count);\n\n        const vertexBuf = vb.getBuffer('aVertexPosition');\n        const vs = vb.stride * vertices;\n\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\n        {\n            // !@#$ happens, need resize\n            let bk = vb.stride;\n\n            while (bk < vs)\n            {\n                bk *= 2;\n            }\n            this.vbBuffer = new ArrayBuffer(bk);\n            this.vbArray = new Float32Array(this.vbBuffer);\n            this.vbInts = new Uint32Array(this.vbBuffer);\n        }\n\n        const arr = this.vbArray;\n        const ints = this.vbInts;\n        let sz = 0;\n        let textureId = 0;\n\n        for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\n        {\n            const eps = 0.5;\n\n            if (this.compositeParent)\n            {\n                textureId = points[i + POINT_STRUCT.TEXTURE_INDEX];\n            }\n            const x = points[i + POINT_STRUCT.X];\n            const y = points[i + POINT_STRUCT.Y];\n            const w = points[i + POINT_STRUCT.TILE_WIDTH];\n            const h = points[i + POINT_STRUCT.TILE_HEIGHT];\n            const u = points[i + POINT_STRUCT.U];\n            const v = points[i + POINT_STRUCT.V];\n            let rotate = points[i + POINT_STRUCT.ROTATE];\n\n            const animX = points[i + POINT_STRUCT.ANIM_X];\n            const animY = points[i + POINT_STRUCT.ANIM_Y];\n            const animWidth = points[i + POINT_STRUCT.ANIM_COUNT_X] || 1024;\n            const animHeight = points[i + POINT_STRUCT.ANIM_COUNT_Y] || 1024;\n\n            const animXEncoded = animX + (animWidth * 2048);\n            const animYEncoded = animY + (animHeight * 2048);\n            const animDivisor = points[i + POINT_STRUCT.ANIM_DIVISOR];\n            const colR = points[i + POINT_STRUCT.COL_R];\n            const colG = points[i + POINT_STRUCT.COL_G];\n            const colB = points[i + POINT_STRUCT.COL_B];\n            const colA = points[i + POINT_STRUCT.COL_A];\n\n            let u0: number;\n            let v0: number; let u1: number;\n            let v1: number; let u2: number;\n            let v2: number; let u3: number;\n            let v3: number;\n\n            if (rotate === 0)\n            {\n                u0 = u;\n                v0 = v;\n                u1 = u + w;\n                v1 = v;\n                u2 = u + w;\n                v2 = v + h;\n                u3 = u;\n                v3 = v + h;\n            }\n            else\n            {\n                let w2 = w / 2;\n                let h2 = h / 2;\n\n                if (rotate % 4 !== 0)\n                {\n                    w2 = h / 2;\n                    h2 = w / 2;\n                }\n                const cX = u + w2;\n                const cY = v + h2;\n\n                rotate = groupD8.add(rotate, groupD8.NW);\n                u0 = cX + (w2 * groupD8.uX(rotate));\n                v0 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n                u1 = cX + (w2 * groupD8.uX(rotate));\n                v1 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2);\n                u2 = cX + (w2 * groupD8.uX(rotate));\n                v2 = cY + (h2 * groupD8.uY(rotate));\n\n                rotate = groupD8.add(rotate, 2);\n                u3 = cX + (w2 * groupD8.uX(rotate));\n                v3 = cY + (h2 * groupD8.uY(rotate));\n            }\n            if(arr && ints) {\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u0;\n                arr[sz++] = v0;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                ints[sz++] = textureId;\n                arr[sz++] = animDivisor;\n                arr[sz++] = colR;\n                arr[sz++] = colG;\n                arr[sz++] = colB;\n                arr[sz++] = colA;\n\n                arr[sz++] = x + w;\n                arr[sz++] = y;\n                arr[sz++] = u1;\n                arr[sz++] = v1;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                ints[sz++] = textureId;\n                arr[sz++] = animDivisor;\n                arr[sz++] = colR;\n                arr[sz++] = colG;\n                arr[sz++] = colB;\n                arr[sz++] = colA;\n\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u2;\n                arr[sz++] = v2;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                ints[sz++] = textureId;\n                arr[sz++] = animDivisor;\n                arr[sz++] = colR;\n                arr[sz++] = colG;\n                arr[sz++] = colB;\n                arr[sz++] = colA;\n\n                arr[sz++] = x;\n                arr[sz++] = y + h;\n                arr[sz++] = u3;\n                arr[sz++] = v3;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                ints[sz++] = textureId;\n                arr[sz++] = animDivisor;\n                arr[sz++] = colR;\n                arr[sz++] = colG;\n                arr[sz++] = colB;\n                arr[sz++] = colA;\n            } else {\n                throw new Error('Buffer is not initialized');\n            }\n        }\n        vertexBuf.data = arr ?? new Float32Array();\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        if (this.rects_count * POINT_STRUCT_SIZE !== this.pointsBuf.length\n            || (anim && this.hasAnimatedTile))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This will pull forward the modification marker.\n     *\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        this.rects_count = this.pointsBuf.length / POINT_STRUCT_SIZE;\n    }\n\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.tilemapBounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    get bounds()\n    {\n        return this.tilemapBounds;\n    }\n\n    /** @override */\n    destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n        this.destroyVb();\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\n    {\n        this.tile(\n            texture,\n            x,\n            y,\n            {\n                animX,\n                animY,\n            }\n        );\n\n        return true;\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX = 0,\n        animY = 0,\n        rotate = 0,\n        animCountX = 1024,\n        animCountY = 1024,\n        animDivisor = 1,\n        colR = 1,\n        colG = 1,\n        colB = 1,\n        colA = 1\n    ): this\n    {\n        return this.tile(\n            textureIndex,\n            x, y,\n            {\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY, animDivisor, colR, colG, colB, colA\n            }\n        );\n    }\n}\n","import { Container, Texture, TextureSource } from 'pixi.js';\r\nimport { settings } from './settings';\r\nimport { Tilemap } from './Tilemap';\r\n\r\nexport class CompositeTilemap extends Container\r\n{\r\n    /** The hard limit on the number of tile textures used in each tilemap. */\r\n    public readonly texturesPerTilemap: number;\r\n\r\n    /**\r\n     * The animation frame vector.\r\n     *\r\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n     * row and `animCountY` per column.\r\n     *\r\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n     */\r\n    public tileAnim: [number, number] | null = null;\r\n\r\n    /** The last modified tilemap. */\r\n    protected lastModifiedTilemap: Tilemap | null = null;\r\n\r\n    private modificationMarker = 0;\r\n    // private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n\r\n    /**\r\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n     *  will work equivalently.\r\n     */\r\n    constructor(tileset?: Array<TextureSource>)\r\n    {\r\n        super();\r\n\r\n        this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\r\n        this.tileset(tileset);\r\n    }\r\n\r\n    /**\r\n     * This will preinitialize the tilesets of the layered tilemaps.\r\n     *\r\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n     *\r\n     * @param tileTextures - The list of tile textures that make up the tileset.\r\n     */\r\n    tileset(tileTextures?: Array<TextureSource>): this\r\n    {\r\n        if (!tileTextures)\r\n        {\r\n            tileTextures = [];\r\n        }\r\n\r\n        const texPerChild = this.texturesPerTilemap;\r\n        const len1 = this.children.length;\r\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\r\n\r\n        for (let i = 0; i < Math.min(len1, len2); i++)\r\n        {\r\n            (this.children[i] as Tilemap).setTileset(\r\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\r\n            );\r\n        }\r\n        for (let i = len1; i < len2; i++)\r\n        {\r\n            const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\r\n\r\n            tilemap.compositeParent = true;\r\n\r\n            // TODO: Don't use children\r\n            this.addChild(tilemap);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Clears the tilemap composite. */\r\n    clear(): this\r\n    {\r\n        for (let i = 0; i < this.children.length; i++)\r\n        {\r\n            (this.children[i] as Tilemap).clear();\r\n        }\r\n\r\n        this.modificationMarker = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes the rotation of the last added tile. */\r\n    tileRotate(rotate: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileRotate(rotate);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animX`, `animCountX` of the last added tile. */\r\n    tileAnimX(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimX(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `animY`, `animCountY` of the last added tile. */\r\n    tileAnimY(offset: number, count: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimY(offset, count);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Changes `tileAnimDivisor` value of the last added tile. */\r\n    tileAnimDivisor(divisor: number): this\r\n    {\r\n        if (this.lastModifiedTilemap)\r\n        {\r\n            this.lastModifiedTilemap.tileAnimDivisor(divisor);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a tile that paints the given tile texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n     * @param x - The local x-coordinate of the tile's location.\r\n     * @param y - The local y-coordinate of the tile's location.\r\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n     * @param [options.colR=1] - Tile red multiplier.\r\n     * @param [options.colG=1] - Tile green multiplier.\r\n     * @param [options.colB=1] - Tile blue multiplier.\r\n     * @param [options.colA=1] - Tile alpha multiplier.\r\n     * @return This tilemap, good for chaining.\r\n     */\r\n    tile(\r\n        tileTexture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        options: {\r\n            u?: number,\r\n            v?: number,\r\n            tileWidth?: number,\r\n            tileHeight?: number,\r\n            animX?: number,\r\n            animY?: number,\r\n            rotate?: number,\r\n            animCountX?: number,\r\n            animCountY?: number,\r\n            animDivisor?: number,\r\n            colR?: number,\r\n            colG?: number,\r\n            colB?: number,\r\n            colA?: number,\r\n        } = {}\r\n    ): this\r\n    {\r\n        let tilemap: Tilemap | null = null;\r\n        const children = this.children;\r\n\r\n        this.lastModifiedTilemap = null;\r\n\r\n        if (typeof tileTexture === 'number')\r\n        {\r\n            const childIndex = tileTexture / this.texturesPerTilemap >> 0;\r\n            let tileIndex = 0;\r\n\r\n            tilemap = children[childIndex] as Tilemap;\r\n\r\n            if (!tilemap)\r\n            {\r\n                tilemap = children[0] as Tilemap;\r\n\r\n                // Silently fail if the tilemap doesn't exist\r\n                if (!tilemap) return this;\r\n\r\n                tileIndex = 0;\r\n            }\r\n            else\r\n            {\r\n                tileIndex = tileTexture % this.texturesPerTilemap;\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileIndex,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n        else\r\n        {\r\n            if (typeof tileTexture === 'string')\r\n            {\r\n                tileTexture = Texture.from(tileTexture);\r\n            }\r\n\r\n            // Probe all tilemaps to find which tileset contains the base-texture.\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                const child = children[i] as Tilemap;\r\n                const tex = child.getTileset().arr;\r\n\r\n                for (let j = 0; j < tex.length; j++)\r\n                {\r\n                    if (tex[j] === tileTexture.source)\r\n                    {\r\n                        tilemap = child;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (tilemap)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If no tileset contains the base-texture, attempt to add it.\r\n            if (!tilemap)\r\n            {\r\n                // Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\r\n                for (let i = children.length - 1; i >= 0; i--)\r\n                {\r\n                    const child = children[i] as Tilemap;\r\n\r\n                    if (child.getTileset().count < this.texturesPerTilemap)\r\n                    {\r\n                        tilemap = child;\r\n                        child.getTileset().push(tileTexture.source);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Otherwise, create a new tilemap initialized with that tile texture.\r\n                if (!tilemap)\r\n                {\r\n                    tilemap = new Tilemap(tileTexture.source);\r\n                    tilemap.compositeParent = true;\r\n\r\n                    this.addChild(tilemap);\r\n                }\r\n            }\r\n\r\n            tilemap.tile(\r\n                tileTexture,\r\n                x,\r\n                y,\r\n                options,\r\n            );\r\n        }\r\n\r\n        this.lastModifiedTilemap = tilemap;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    isModified(anim: boolean): boolean\r\n    {\r\n        const layers = this.children;\r\n\r\n        if (this.modificationMarker !== layers.length)\r\n        {\r\n            return true;\r\n        }\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            if ((layers[i] as Tilemap).isModified(anim))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @ignore\r\n     */\r\n    clearModify(): void\r\n    {\r\n        const layers = this.children;\r\n\r\n        this.modificationMarker = layers.length;\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            (layers[i] as Tilemap).clearModify();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    addFrame(\r\n        texture: Texture | string | number,\r\n        x: number,\r\n        y: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        animWidth?: number,\r\n        animHeight?: number,\r\n        animDivisor?: number,\r\n        colR?: number,\r\n        colG?: number,\r\n        colB?: number,\r\n        colA?: number\r\n    ): this\r\n    {\r\n        return this.tile(\r\n            texture,\r\n            x, y,\r\n            {\r\n                animX,\r\n                animY,\r\n                animCountX: animWidth,\r\n                animCountY: animHeight,\r\n                animDivisor,\r\n                colR,\r\n                colG,\r\n                colB,\r\n                colA,\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @deprecated @pixi/tilemap 3\r\n     * @see CompositeTilemap.tile\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    addRect(\r\n        textureIndex: number,\r\n        u: number,\r\n        v: number,\r\n        x: number,\r\n        y: number,\r\n        tileWidth: number,\r\n        tileHeight: number,\r\n        animX?: number,\r\n        animY?: number,\r\n        rotate?: number,\r\n        animWidth?: number,\r\n        animHeight?: number\r\n    ): this\r\n    {\r\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\r\n        const textureId: number = textureIndex % this.texturesPerTilemap;\r\n\r\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset().count > 0)\r\n        {\r\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\r\n            this.lastModifiedTilemap.addRect(\r\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\r\n            );\r\n        }\r\n        else\r\n        {\r\n            this.lastModifiedTilemap = null;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for {@link CompositeTilemap.tileset tileset}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */\r\n    setBitmaps = this.tileset;\r\n\r\n    /**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @readonly\r\n     * @see CompositeTilemap.texturesPerTilemap\r\n     */\r\n    get texPerChild(): number { return this.texturesPerTilemap; }\r\n}\r\n","// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\r\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\r\nimport { extensions } from 'pixi.js';\r\nimport { GlTilemapAdaptor } from './gl_tilemap';\r\nimport { GpuTilemapAdaptor } from './gpu_tilemap';\r\nimport { TilemapPipe } from './TilemapPipe';\r\n\r\nexport * from './CompositeTilemap';\r\nexport * from './settings';\r\nexport * from './Tilemap';\r\nexport * from './TilemapGeometry';\r\nexport * from './TilemapPipe';\r\n\r\nextensions.add(TilemapPipe);\r\nextensions.add(GlTilemapAdaptor);\r\nextensions.add(GpuTilemapAdaptor);\r\n"],"names":["settings","Constant","i","b","o","s","t","_TilemapGeometry","Geometry","indexBuffer","buf","Buffer","BufferUsage","stride","__publicField","TilemapGeometry","TilemapAdaptor","UniformGroup","Matrix","TilemapPipe","renderer","adaptor","geom","size","totalIndices","len","createIndicesForQuads","_renderable","_a","tilemap","instructionSet","batcher","_instructionSet","renderable","pipe_uniforms","u_proj_trans","u_global","anim_frame","u_anim_frame","ExtensionType","outBuffer","j","TileTextureArray","max_textures","tex","ind","tex_sizes","arr","count","null_color","bind_group_resources","bindIndex","texture","Texture","BindGroup","src","sampleValues","samplerSize","gl_tilemap_vertex","gl_tilemap_fragment","GlTilemapAdaptor","pipe","shader","tileset","tu","Shader","GlProgram","gpu_tilemap_vertex","gpu_tilemap_fragment","GpuTilemapAdaptor","tilesetBindGroup","selfBindGroup","GpuProgram","POINT_STRUCT","n","POINT_STRUCT_SIZE","Tilemap","Container","State","Bounds","v","res","textureOrArray","_b","ts","TextureSource","flag","tileTexture","x","y","options","_c","_d","baseTexture","textureIndex","was_num","textureList","u","tileWidth","tileHeight","animX","animY","rotate","animCountX","animCountY","animDivisor","colR","colG","colB","colA","pb","offset","divisor","r","g","a","plugin","points","rects_count","vb","vertices","vertexBuf","vs","bk","ints","sz","textureId","w","h","animWidth","animHeight","animXEncoded","animYEncoded","u0","v0","u1","v1","u2","v2","u3","v3","w2","h2","cX","cY","groupD8","anim","bounds","_bounds","M","e","d","CompositeTilemap","tileTextures","texPerChild","len1","len2","children","childIndex","tileIndex","child","layers","extensions"],"mappings":"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"}